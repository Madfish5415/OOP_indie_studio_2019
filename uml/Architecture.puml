@startuml

namespace engine {

    namespace event {
        class Input {
            + Input()
            + ~Input()
        }

        class Collision {
            + Collision()
            + ~Collision()
        }

        class Close {
            + Close()
            + ~Close()
        }
    }

    namespace ecs {
        'using Entity = unsigned int
        'const Entity MAX_ENTITIES = 1000
        'using ComponentType = unsigned int
        'const ComponentType MAX_COMPONENTS = 32
        'using Signature = std::bitset<MAX_COMPONENTS>

        class WorldManager {
            + WorldManager()
            + ~WorldManager() = default

            + Entity createEntity()
            + void destroyEntity(Entity entity)

            + template<typename T> void registerComponent()
            + template<typename T> void addComponent(Entity entity, T component)
            + template<typename T> void removeComponent(Entity entity)
            + template<typename T> T& getComponent(Entity entity)
            + template<typename T> ComponentType getComponentType()

            + template<typename T> std::shared_ptr<T> registerSystem()
            + template<typename T> void setSystemSignature(Signature signature)

            + template<typename T, typename E> void subscribe(T& subscriber, Callback<T, E> callback)
            + void unsubscribe()

            + template<typname E> void publish(E& event)

            - std::unique_ptr<EventManager> _eventManager
            - std::unique_ptr<EntityManager> _entityManager
            - std::unique_ptr<SystemManager> _systemManager
            - std::unique_ptr<ComponentManager> _componentManager
        }

        class EntityManager {
            + EntityManager()
            + ~EntityManager() = default

            + Entity createEntity()
            + void destroyEntity(Entity entity)

            + void setSignature(Entity entity, Signature signature)
            + Signature& getSignature(Entity entity)

            - std::queue<Entity> _availableEntities
            - std::array<Signature, MAX_ENTITIES> _signatures
            - size_t _entitiesCount
        }

        class SystemManager {
            + SystemManager() = default
            + ~SystemManager() = default

            + template<typename T> std::shared_ptr<T> registerSystem()

            + template<typename T> void setSignature(Signature signature)

            + void entityDestroyed(Entity entity)

            + void entitySignatureChanged(Entity entity, Signature entSignature)

            - std::unordered_map<std::string, std::shared_ptr<System>> _systems
            - std::unordered_map<std::string, Signature> _signatures
        }

        class ComponentManager {
            + ComponentManager() = default
            + ~ComponentManager() = default

            + template<typename T> void registerComponent()

            - template<typename T> std::shared_ptr<ComponentArray<T>> getComponentArray()

            + template<typename T> ComponentType getComponentType()
            + template<typename T> void addComponent(Entity entity, T component)
            + template<typename T> void removeComponent(Entity entity)
            + template<typename T> T& getComponent(Entity entity)

            + void entityDestroyed(Entity entity)

            - std::unordered_map<std::string, ComponentType> _componentTypes
            - std::unordered_map<std::string, std::shared_ptr<IComponentArray>> _componentArrays
            - ComponentType _componentType
        }

        class IComponentArray {
            + virtual ~IComponentArray() = default

            + virtual void entityDestroyed(Entity entity) = 0
        }

        'template<typename T>
        class ComponentArray {
            + ComponentArray() = default
            + ~ComponentArray() override = default

            + void insert(Entity entity, T component)
            + void remove(Entity entity)
            + T& get(Entity entity)

            + void entityDestroyed(Entity entity) override

            - std::array<T, MAX_ENTITIES> _componentArray
            - std::unordered_map<Entity, size_t> _entityToIndex
            - std::unordered_map<size_t, Entity> _indexToEntity
            - size_t _size
        }
        IComponentArray <|-- ComponentArray

        class System {
            + System()
            + ~System()

            + std::set<Entity> entities
        }

        class EventManager {
            + EventManager() = default
            + ~EventManager()

            + template<typename T, typename E> void subscribe(T& subscriber, Callback<T, E> callback)
            + void unsubscribe()

            + template<typname E> void publish(E& event)

            - std::map<std::type_index, std::vector<ICallbackHandler*>*> _subscribers
        }

        class ICallbackHandler {
            + virtual ~ICallbackHandler() = default

            + virtual void call(AEvent& event) = 0
        }
        EventManager +-- ICallbackHandler

        'template<typename T, typename E> using Callback = void (T::*)(E&)
        'template<typename T, typename E>
        class CallbackHandler {
            + CallbackHandler(T& subscriber, Callback<T, E> callback)
            + ~CallbackHandler() override = default

            + void call(AEvent& event) override

            - T& _subscriber
            - Callback<T, E> _callback
        }
        EventManager +-- CallbackHandler
        ICallbackHandler <|-- CallbackHandler

        class AEvent {
            + AEvent() = delete
            + ~AEvent() = default
        }
        AEvent <|-- engine.event.Input
        AEvent <|-- engine.event.Close
        AEvent <|-- engine.event.Collision
    }

    namespace system {
        class Player {
            + Player(ISceneManager* smgr)
            + ~Player()

            + ISceneManager* smgr
        }
        engine.ecs.System <|-- User

        class AI {
            + AI()
            + ~AI()

            + void init()
            + void update()
            + void render()

            + ISceneManager* smgr
        }
        engine.ecs.System <|-- AI

        class Music {
            + Music(ISceneManager* smgr)
            + ~Music()

            + void init()
            + void update()
            + void render()

            + ISceneManager* smgr
        }
        engine.ecs.System <|-- Music

        class Animation {
            + Animation(ISceneManager* smgr)
            + ~Animation()

            + void init()
            + void update()
            + void render()

            + ISceneManager* smgr
        }
        engine.ecs.System <|-- Animation

        class Movement {
            + Movement(ISceneManager* smgr)
            + ~Movement()

            + void init()
            + void update()
            + void render()

            + ISceneManager* smgr
        }
        engine.ecs.System <|-- Movement

        class Render {
            + Render(ISceneManager* smgr)
            + ~Render()

            + void init()
            + void update()
            + void render()

            + ISceneManager* smgr
        }
        engine.ecs.System <|-- Render

        class Physics {
            + Physics(ISceneManager* smgr)
            + ~Physics()

            + void init()
            + void update()
            + void render()

            + ISceneManager* smgr
        }
        engine.ecs.System <|-- Physics

        class Size {
            + Size(ISceneManager* smgr)
            + ~Size()

            + void init()
            + void update()
            + void render()

            + ISceneManager* smgr
        }
        engine.ecs.System <|-- Size

        class Image {
            + Image(irr:video::IVideoDriver* driver)
            + ~Image()

            + void init()
            + void update()
            + void render()

            + irr::video::IVideoDriver* driver
        }
    }

    namespace component {
        class Player {
            + Player(irr::EKEY_CODE left, irr::EKEY_CODE right, irr::EKEY_CODE up, irr::EKEY_CODE down, irr::EKEY_CODE bomb)
            + ~Player()

            + irr::EKEY_CODE left
            + irr::EKEY_CODE right
            + irr::EKEY_CODE up
            + irr::EKEY_CODE down
            + irr::EKEY_CODE bomb
        }

        class AI {
            + AI()
            + ~AI()
        }

        class Music {
            + Music()
            + ~Music()

            + sf::Music music
        }

        class Sound {
            + Sound()
            + ~Sound()

            + std::map<std::string, sf::Music>
        }

        class Motion {
            + Motion(float movementSpeed)
            + ~Motion()

            + float movementSpeed
            + irr::core::vector3df direction
        }

        class Animation {
            + Animation()
            + ~Animation()

            + std::map<std::string, std::pair<size_t, size_t>> animationRanges
        }

        class LookingView {
            + LookingView()
            + ~LookingView()

            + irr::core::vector3df direction
        }

        class Render3d {
            + Render(irr::ISceneNode* node)
            + ~Render()

            + irr::ISceneNode* node
        }

        class BombTimer {
            + BombTimer(irr::u32 duration)
            + ~BombTimer()

            + irr::u32 timerStart
            + irr::u32 duration
        }

        class Stats {
            + Stats()
            + ~Stats()

            + size_t moveSpeed
            + size_t bombRadius
            + size_t maxBomb
            + bool wallPass
        }

        class Unbreakable {
            + Unbreakable()
            + ~Unbreakable()
        }

        class Lootable {
            + Lootable()
            + ~Lootable()
        }

        class BombStats {
            + BombStats (size_t bombRadius, bool wallPass)
            + ~BombStats()

            + size_t bombRadius
            + bool wallPass
        }

        class Owner {
            + Owner(const size_t ID)
            + ~Owner()

            + size_t entityID
        }

        class Transform {
            + Transform(irr::core::vector3df position)
            + ~Transform()

            + irr::core::vector3df position
        }

        class HitboxDetection {
            + Hitbox()
            + ~Hitbox()

            + std::vector<irr::core::line3d> rays
        }

        class Size {
            + Size(irr::core::vector3df size)
            + ~Size()

            + irr::core::vector3df size
        }

        class Text {
            + Text(irr::gui::irr::gui::IGUIEnvironment* gui, const wchar_t * text, const core::rect<s32> &rectangle, bool border = false, bool wordWrap = true, IGUIElement *parent = 0, s32 id = -1, bool fillBackground = false)
            + ~Text()

            + void setFont(std::string path)

            + irr::gui::IGUIStaticText* text
            + irr::gui::IGUIFont* font
        }

        class Button {
            + Button(irr::gui::IGUIEnvironment* gui, irr::core::rect<irr::s32> position, IGUIElement* parent = 0, s32 id = -1, const wchar_t* text = 0, const wchar_t* tooltipText = 0)
            + ~Button()

            + void setFont(std::string path)
            + void setImage(std::string path)
            + void setPressedImage(std::string path)

            + irr::gui::IGUIEnvironment* gui
            + irr::gui::IGUIButton* button
        }

        class MessageBox {
            + MessageBox(irr::gui::IGUIEnvironment* gui, const wchar_t *caption, const wchar_t *text, bool modal = true, s32 flags = EMBF_OK, IGUIEnvironment* parent = 0, s32 id = -1, irr::video::ITexture* image = 0)
            + ~MessageBox()

            + irr::gui::IGUIEnvironment* gui
            + irr:gui::IGUIWindow* messageBox
        }

        class Image {
            + Image(irr::video::IVideoDriver* driver, std::string texture, irr::core::position2d<irr::s32> position, irr::core::rect<irr::s32> rect, irr::core::rect<irr::s32> *clipRect = 0, irr::video::SColor scolor = irr::video::SColor(255, 255, 255, 255), bool useAlphaChannelOfTexture = false )
            + ~Image()

            + irr::video::IVideoDriver* driver
            + irr::video::ITexture* image
            + irr::core::position2d<irr::s32> position
            + irr::core::rect<irr::s32> rect
            + irr::core::rect<irr::s32> *clipRect
            + irr::video::SColor scolor
            + bool useAlphaChannelOfTexture
        }
    }
}



@enduml
